#!/bin/bash
set -e

# Project utility script
WORKSPACE="/usr/src/app"

# Helper functions
error() { printf 'ERROR: %s\n' "$1" >&2; exit 1; }
info() { printf 'INFO: %s\n' "$1"; }
warn() { printf 'WARNING: %s\n' "$1" >&2; }
success() { printf 'âœ“ SUCCESS: %s\n' "$1"; }

# Ask for user confirmation
confirm() {
    printf '%s [y/N]: ' "$1"
    read -r answer
    case "$answer" in
        [Yy]|[Yy][Ee][Ss]) return 0 ;;
        *) return 1 ;;
    esac
}

# Load environment variables from .env
load_env() {
    if [ -f "$WORKSPACE/.env" ]; then
        set -a
        . "$WORKSPACE/.env"
        set +a
    fi
}

# Show help
show_help() {
    cat << 'EOF'
Usage: cmd COMMAND [OPTIONS]

App Management (Spring Boot):
  cmd app build                     Build application (mvn package)
  cmd app run                       Run in dev mode with hot reload (mvn spring-boot:run)
  cmd app start                     Start application
  cmd app stop                      Stop application
  cmd app restart                   Restart application
  cmd app status                    Show application status

GUI Management (Vite/Svelte):
  cmd gui build                     Build GUI (npm run build)
  cmd gui start                     Start Vite dev server
  cmd gui stop                      Stop Vite dev server
  cmd gui restart                   Restart Vite dev server
  cmd gui status                    Show Vite status

Git Operations:
  cmd git push [-r <path>]          Stage, commit and push changes
  cmd git pull [-r <path>]          Pull changes from remote
  cmd git sync [-r <path>]          Sync repository (pull + push)
  cmd git branch -b <name> [-r <path>]  Create/switch to branch
  cmd git merge -b <name> [-r <path>]   Merge branch into main and delete

Git Options:
  -r, --repo <path>                 Use git repo at <path> (default: project root)
                                    Example: cmd git push -r .springtools

Sync Operations (rsync based):
  cmd sync -r <path>                Sync directories using .sync config file
                                    Example: cmd sync -r .myrepo
                                    The .sync file format (semicolon separated):
                                    source;destination;includes;excludes

Options:
  -h, --help                        Show this help message
EOF
}

# ============================================================================
# App Operations (Spring Boot)
# ============================================================================

APP_PID_FILE="$WORKSPACE/.app.pid"

app_build() {
    load_env
    info "Building Spring Boot application..."
    cd "$WORKSPACE"
    mvn clean package -DskipTests
    success "Build completed"
}

app_start() {
    load_env

    if app_is_running; then
        warn "Application is already running (PID: $(cat $APP_PID_FILE))"
        return 0
    fi

    local JAR_FILE="$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"

    if [ ! -f "$JAR_FILE" ]; then
        error "JAR not found: $JAR_FILE. Run 'cmd app build' first."
    fi

    info "Starting Spring Boot application..."
    cd "$WORKSPACE"
    nohup java -jar "$JAR_FILE" > "$WORKSPACE/app.log" 2>&1 &
    echo $! > "$APP_PID_FILE"

    sleep 2
    if app_is_running; then
        success "Application started (PID: $(cat $APP_PID_FILE))"
        info "Log: $WORKSPACE/app.log"
        info "Internal: http://localhost:${DEV_PORT}/"
        info "External: http://localhost:${DEV_PORT_HOST}/"
    else
        error "Failed to start application. Check app.log"
    fi
}

app_stop() {
    if ! app_is_running; then
        info "Application is not running"
        return 0
    fi

    local PID=$(cat "$APP_PID_FILE")
    info "Stopping application (PID: $PID)..."
    kill "$PID" 2>/dev/null || true

    # Wait for process to stop
    local COUNT=0
    while kill -0 "$PID" 2>/dev/null && [ $COUNT -lt 10 ]; do
        sleep 1
        COUNT=$((COUNT + 1))
    done

    if kill -0 "$PID" 2>/dev/null; then
        warn "Force killing application..."
        kill -9 "$PID" 2>/dev/null || true
    fi

    rm -f "$APP_PID_FILE"
    success "Application stopped"
}

app_restart() {
    app_stop
    sleep 1
    app_start
}

app_status() {
    load_env
    echo "=== Spring Boot Application Status ==="

    if app_is_running; then
        local PID=$(cat "$APP_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        echo "Internal: http://localhost:${DEV_PORT}/"
        echo "External: http://localhost:${DEV_PORT_HOST}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "JAR: $WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"
    if [ -f "$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar" ]; then
        echo "JAR exists: YES"
    else
        echo "JAR exists: NO (run 'cmd app build')"
    fi
}

app_is_running() {
    if [ -f "$APP_PID_FILE" ]; then
        local PID=$(cat "$APP_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$APP_PID_FILE"
    fi
    return 1
}

app_run() {
    load_env
    info "Starting Spring Boot in development mode with auto-reload..."
    info "DevTools enabled - save a Java file and it will auto-reload"
    cd "$WORKSPACE"

    # Create timestamp file for tracking changes
    TIMESTAMP_FILE="$WORKSPACE/.watch_timestamp"
    touch "$TIMESTAMP_FILE"

    # Start a background process to watch for changes and compile
    (
        while true; do
            sleep 2
            # Check if any Java file is newer than our timestamp
            if find src/main/java -name '*.java' -newer "$TIMESTAMP_FILE" 2>/dev/null | grep -q .; then
                echo "[WATCH] Detected changes, recompiling..."
                touch "$TIMESTAMP_FILE"
                mvn compile -q 2>&1 | grep -v "^\[INFO\]" || true
                echo "[WATCH] Compilation done"
            fi
        done
    ) &
    WATCH_PID=$!

    # Trap to kill watcher on exit
    trap "kill $WATCH_PID 2>/dev/null || true; rm -f $TIMESTAMP_FILE" EXIT

    # Start Spring Boot
    mvn spring-boot:run
}

# ============================================================================
# GUI Operations (Vite/Svelte)
# ============================================================================

GUI_PID_FILE="$WORKSPACE/.gui.pid"
GUI_DIR="$WORKSPACE/gui"

gui_build() {
    load_env

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Building Svelte application..."
    cd "$GUI_DIR"
    npm run build
    success "GUI build completed (output: src/main/resources/static/)"
}

gui_start() {
    load_env

    if gui_is_running; then
        warn "Vite dev server is already running (PID: $(cat $GUI_PID_FILE))"
        return 0
    fi

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Starting Vite dev server..."
    cd "$GUI_DIR"
    nohup npm run dev > "$WORKSPACE/gui.log" 2>&1 &
    echo $! > "$GUI_PID_FILE"

    sleep 2
    if gui_is_running; then
        success "Vite dev server started (PID: $(cat $GUI_PID_FILE))"
        info "Log: $WORKSPACE/gui.log"
        info "URL: http://localhost:${VITE_PORT}/"
        info "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
    else
        error "Failed to start Vite. Check gui.log"
    fi
}

gui_stop() {
    if ! gui_is_running; then
        info "Vite dev server is not running"
        return 0
    fi

    local PID=$(cat "$GUI_PID_FILE")
    info "Stopping Vite dev server (PID: $PID)..."

    # Kill the process and its children (node processes)
    pkill -P "$PID" 2>/dev/null || true
    kill "$PID" 2>/dev/null || true

    sleep 1
    if kill -0 "$PID" 2>/dev/null; then
        kill -9 "$PID" 2>/dev/null || true
    fi

    rm -f "$GUI_PID_FILE"
    success "Vite dev server stopped"
}

gui_restart() {
    gui_stop
    sleep 1
    gui_start
}

gui_status() {
    load_env
    echo "=== Vite/Svelte GUI Status ==="

    if gui_is_running; then
        local PID=$(cat "$GUI_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        echo "URL: http://localhost:${VITE_PORT}/"
        echo "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "GUI directory: $GUI_DIR"
    if [ -d "$GUI_DIR" ]; then
        echo "Directory exists: YES"
    else
        echo "Directory exists: NO"
    fi
}

gui_is_running() {
    if [ -f "$GUI_PID_FILE" ]; then
        local PID=$(cat "$GUI_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$GUI_PID_FILE"
    fi
    return 1
}

# ============================================================================
# Git Operations
# ============================================================================

# Updates a git repository (stage, commit, push)
update_git_repo() {
    local REPO_DIR="$1"
    local REPO_NAME="$2"

    info "Updating repository in $REPO_DIR..."

    if [ ! -d "$REPO_DIR" ]; then
        warn "Directory $REPO_DIR does not exist, skipping"
        return 0
    fi

    if [ ! -d "$REPO_DIR/.git" ]; then
        warn "$REPO_DIR is not a git repository, skipping"
        return 0
    fi

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"
    #git remote set-url origin "https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${REPO_NAME}.git"

    # Stage changes
    info "  Staging changes..."
    git add . || { warn "Failed to stage changes"; cd "$WORKSPACE"; return 1; }

    # Commit changes
    info "  Creating commit..."
    if git commit -m "updated" 2>/dev/null; then
        info "  Changes committed"
    else
        info "  No changes to commit"
        cd "$WORKSPACE"
        return 0
    fi

    # Push to remote
    info "  Pushing to remote..."
    if git push 2>/dev/null; then
        success "Successfully pushed"
    else
        warn "Failed to push changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Pulls changes from git repository
pull_git_repo() {
    local REPO_DIR="$1"
    local REPO_NAME="$2"

    info "Pulling repository in $REPO_DIR..."

    if [ ! -d "$REPO_DIR" ]; then
        warn "Directory $REPO_DIR does not exist, skipping"
        return 0
    fi

    if [ ! -d "$REPO_DIR/.git" ]; then
        warn "$REPO_DIR is not a git repository, skipping"
        return 0
    fi

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"
    # git remote set-url origin "https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${REPO_NAME}.git"

    # Pull from remote
    info "  Pulling from remote..."
    if git pull 2>/dev/null; then
        success "Successfully pulled"
    else
        warn "Failed to pull changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Resolve repo path and name from -r option
resolve_repo() {
    local REPO_PATH="$1"

    if [ -z "$REPO_PATH" ]; then
        # Default: project root
        GIT_REPO_DIR="$WORKSPACE"
        GIT_REPO_NAME="${PROJECT_NAME}"
    else
        # Custom path specified with -r
        if [[ "$REPO_PATH" = /* ]]; then
            GIT_REPO_DIR="$REPO_PATH"
        else
            GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
        fi
        # Derive repo name from folder name (remove leading dot if present)
        local FOLDER_NAME=$(basename "$GIT_REPO_DIR")
        FOLDER_NAME="${FOLDER_NAME#.}"
        GIT_REPO_NAME="${PROJECT_NAME}-${FOLDER_NAME}"
    fi
}

# Push changes to git repository
git_push() {
    local REPO_PATH="$1"
    load_env
    resolve_repo "$REPO_PATH"

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Push changes to remote ($GIT_REPO_DIR)?" || exit 0

    info "Starting git push..."

    if [ -d "$GIT_REPO_DIR/.git" ]; then
        update_git_repo "$GIT_REPO_DIR" "$GIT_REPO_NAME"
    else
        error "$GIT_REPO_DIR is not a git repository"
    fi

    info "Git push completed"
}

# Pull changes from git repository
git_pull() {
    local REPO_PATH="$1"
    load_env
    resolve_repo "$REPO_PATH"

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Pull changes from remote ($GIT_REPO_DIR)?" || exit 0

    info "Starting git pull..."

    if [ -d "$GIT_REPO_DIR/.git" ]; then
        pull_git_repo "$GIT_REPO_DIR" "$GIT_REPO_NAME"
    else
        error "$GIT_REPO_DIR is not a git repository"
    fi

    info "Git pull completed"
}

# Sync git repository (pull + push)
git_sync() {
    local REPO_PATH="$1"
    load_env
    resolve_repo "$REPO_PATH"

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Sync repository (pull + commit + push) ($GIT_REPO_DIR)?" || exit 0

    info "Starting git sync..."

    if [ -d "$GIT_REPO_DIR/.git" ]; then
        pull_git_repo "$GIT_REPO_DIR" "$GIT_REPO_NAME"
        update_git_repo "$GIT_REPO_DIR" "$GIT_REPO_NAME"
    else
        error "$GIT_REPO_DIR is not a git repository"
    fi

    info "Git sync completed"
}

# Create or switch to a branch
git_branch() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    load_env
    resolve_repo "$REPO_PATH"

    [ -z "$BRANCH_NAME" ] && error "Branch name is required. Use: cmd git branch -b <branch-name>"

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    info "Processing branch '$BRANCH_NAME' in $GIT_REPO_DIR..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"
    # git remote set-url origin "https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${GIT_REPO_NAME}.git"

    # Check if branch exists locally
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        info "  Branch '$BRANCH_NAME' exists locally, switching..."
        git switch "$BRANCH_NAME" || error "Failed to switch to branch"
    else
        info "  Branch '$BRANCH_NAME' does not exist locally, creating..."
        git switch -c "$BRANCH_NAME" || error "Failed to create branch"
    fi

    # Check if branch exists on remote
    if ! git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
        info "  Branch '$BRANCH_NAME' does not exist on remote, pushing..."
        if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
            success "Branch '$BRANCH_NAME' pushed to remote"
        else
            warn "Failed to push branch to remote"
            cd "$WORKSPACE"
            return 1
        fi
    else
        info "  Branch '$BRANCH_NAME' already exists on remote"
    fi

    cd "$WORKSPACE"
    success "Git branch operation completed for '$BRANCH_NAME'"
}

# Merge branch into main and delete
git_merge() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    load_env
    resolve_repo "$REPO_PATH"

    [ -z "$BRANCH_NAME" ] && error "Branch name is required. Use: cmd git merge -b <branch-name>"

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
        error "Cannot merge main/master branch into itself"
    fi

    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    confirm "Merge branch '$BRANCH_NAME' into main and delete it ($GIT_REPO_DIR)?" || exit 0

    info "Processing merge of '$BRANCH_NAME' in $GIT_REPO_DIR..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"
    # git remote set-url origin "https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${GIT_REPO_NAME}.git"

    # Detect main branch name
    local MAIN_BRANCH="main"
    if git show-ref --verify --quiet "refs/heads/master"; then
        if ! git show-ref --verify --quiet "refs/heads/main"; then
            MAIN_BRANCH="master"
        fi
    fi

    # Check if branch exists locally
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        error "Branch '$BRANCH_NAME' does not exist locally"
    fi

    # Switch to main branch
    info "  Switching to '$MAIN_BRANCH' branch..."
    git switch "$MAIN_BRANCH" || error "Failed to switch to $MAIN_BRANCH"

    # Merge the branch
    info "  Merging '$BRANCH_NAME' into '$MAIN_BRANCH'..."
    if git merge "$BRANCH_NAME" --no-edit 2>/dev/null; then
        success "Branch '$BRANCH_NAME' merged successfully"
    else
        error "Merge failed. Resolve conflicts manually."
    fi

    # Delete branch locally
    info "  Deleting local branch '$BRANCH_NAME'..."
    if git branch -d "$BRANCH_NAME" 2>/dev/null; then
        info "  Local branch '$BRANCH_NAME' deleted"
    else
        warn "Failed to delete local branch (use -D to force)"
    fi

    # Delete branch from remote
    if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
        info "  Deleting remote branch '$BRANCH_NAME'..."
        if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
            success "Remote branch '$BRANCH_NAME' deleted"
        else
            warn "Failed to delete remote branch"
        fi
    fi

    cd "$WORKSPACE"

    info "Git merge completed"
    info "Note: Use 'cmd git push' to push merged changes to remote"
}

# ============================================================================
# Sync Operations (rsync based on .sync config)
# ============================================================================

# Synchronize directories based on .sync configuration file
sync_repo() {
    local SYNC_DIR="$1"

    if [ -z "$SYNC_DIR" ]; then
        error "Devi specificare la cartella contenente .sync"
    fi

    # Convert to absolute path if relative
    if [[ "$SYNC_DIR" != /* ]]; then
        SYNC_DIR="$WORKSPACE/$SYNC_DIR"
    fi

    local CONFIG_FILE="$SYNC_DIR/.sync"

    if [ ! -f "$CONFIG_FILE" ]; then
        error "File di configurazione .sync non trovato in $SYNC_DIR"
    fi

    info "Starting sync from $CONFIG_FILE..."

    while IFS= read -r line || [ -n "$line" ]; do
        # Ignora righe vuote o commenti
        [ -z "$line" ] && continue
        case "$line" in \#*) continue ;; esac

        ORIG=$(echo "$line" | cut -d';' -f1)
        DEST=$(echo "$line" | cut -d';' -f2)
        INCLUDE_ENTRIES=$(echo "$line" | cut -d';' -f3)
        EXCLUDE_ENTRIES=$(echo "$line" | cut -d';' -f4)

        info "  Syncing: $ORIG -> $DEST"

        # Prepara le opzioni include
        INCLUDE_OPTS=""
        IFS=','
        for i in $INCLUDE_ENTRIES; do
            [ -n "$i" ] && INCLUDE_OPTS="$INCLUDE_OPTS --include='$i'"
        done
        unset IFS

        # Prepara le opzioni exclude
        EXCLUDE_OPTS=""
        IFS=','
        for e in $EXCLUDE_ENTRIES; do
            [ -n "$e" ] && EXCLUDE_OPTS="$EXCLUDE_OPTS --exclude='$e'"
        done
        unset IFS

        # Esegui rsync
        if eval rsync -av --delete $INCLUDE_OPTS $EXCLUDE_OPTS "$ORIG/" "$DEST/" >/dev/null 2>&1; then
            success "  Synced: $ORIG -> $DEST"
        else
            warn "  Failed to sync: $ORIG -> $DEST"
        fi
    done < "$CONFIG_FILE"

    success "Sync completed"
}

# Main sync command handler
sync_main() {
    local REPO_PATH="$1"

    if [ -z "$REPO_PATH" ]; then
        error "Repository path is required. Use: cmd sync -r <repo>"
    fi

    sync_repo "$REPO_PATH"
}

# ============================================================================
# Command parsing
# ============================================================================

case "$1" in
    app)
        case "$2" in
            build)
                app_build
                ;;
            run)
                app_run
                ;;
            start)
                app_start
                ;;
            stop)
                app_stop
                ;;
            restart)
                app_restart
                ;;
            status)
                app_status
                ;;
            *)
                error "Unknown app command: $2. Use: build, run, start, stop, restart, status"
                ;;
        esac
        ;;
    gui)
        case "$2" in
            build)
                gui_build
                ;;
            start)
                gui_start
                ;;
            stop)
                gui_stop
                ;;
            restart)
                gui_restart
                ;;
            status)
                gui_status
                ;;
            *)
                error "Unknown gui command: $2. Use: build, start, stop, restart, status"
                ;;
        esac
        ;;
    git)
        GIT_CMD="$2"
        REPO_PATH=""
        BRANCH_NAME=""
        shift 2

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                -b|--branch)
                    BRANCH_NAME="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        case "$GIT_CMD" in
            push)
                git_push "$REPO_PATH"
                ;;
            pull)
                git_pull "$REPO_PATH"
                ;;
            sync)
                git_sync "$REPO_PATH"
                ;;
            branch)
                git_branch "$BRANCH_NAME" "$REPO_PATH"
                ;;
            merge)
                git_merge "$BRANCH_NAME" "$REPO_PATH"
                ;;
            *)
                error "Unknown git command: $GIT_CMD. Use: push, pull, sync, branch, merge"
                ;;
        esac
        ;;
    sync)
        REPO_PATH=""
        shift 1

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        sync_main "$REPO_PATH"
        ;;
    -h|--help|help|"")
        show_help
        ;;
    *)
        error "Unknown command: $1. Use 'cmd --help' for usage."
        ;;
esac
