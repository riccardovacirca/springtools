#!/bin/bash
set -e

# Project utility script
WORKSPACE="/usr/src/app"

# Helper functions
error() { printf 'ERROR: %s\n' "$1" >&2; exit 1; }
info() { printf 'INFO: %s\n' "$1"; }
warn() { printf 'WARNING: %s\n' "$1" >&2; }
success() { printf 'âœ“ SUCCESS: %s\n' "$1"; }

# Ask for user confirmation
confirm() {
    printf '%s [y/N]: ' "$1"
    read -r answer
    case "$answer" in
        [Yy]|[Yy][Ee][Ss]) return 0 ;;
        *) return 1 ;;
    esac
}

# Load environment variables from .env
load_env() {
    if [ -f "$WORKSPACE/.env" ]; then
        set -a
        . "$WORKSPACE/.env"
        set +a
    fi
}

# Show help
show_help() {
    cat << 'HELPEOF'
Usage: cmd COMMAND [OPTIONS]

App (Spring Boot):
  app build                Build application
  app run                  Run in dev mode (background)
  app start                Start production JAR
  app stop                 Stop application
  app restart              Restart application
  app status               Show status

GUI (Vite/Svelte):
  gui build                Build GUI for production
  gui run                  Run Vite dev server
  gui stop                 Stop Vite server
  gui restart              Restart Vite server
  gui status               Show status

Git:
  git push [-r <path>]     Stage, commit and push
  git pull [-r <path>]     Pull from remote
  git sync [-r <path>]     Pull + commit + push
  git fetch                Initialize repo from remote (only in project root, no .git)
  git branch [-r <path>]   Show current branch name
  git branch -b <name> [-r <path>] [-f <base-branch>]   Create branch from base (default: main)
  git merge -b <name> [-r <path>]    Merge branch to main and delete

Sync:
  sync -r <path>           Sync using .sync config file

Options:
  -h, --help               Show this help
  -r, --repo <path>        Git repo path (default: project root)
  -b, --branch <name>      Branch name
  -f, --from <branch>       Base branch (default: main)
HELPEOF
}

# ============================================================================
# App Operations (Spring Boot)
# ============================================================================

APP_PID_FILE="$WORKSPACE/tmp/app.pid"
APP_WATCH_PID_FILE="$WORKSPACE/tmp/app.watch.pid"

app_build() {
    load_env
    info "Building Spring Boot application..."
    cd "$WORKSPACE"
    mvn clean package -DskipTests
    success "Build completed"
}

app_start() {
    load_env

    if app_is_running; then
        warn "Application is already running (PID: $(cat $APP_PID_FILE))"
        return 0
    fi

    local JAR_FILE="$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"

    if [ ! -f "$JAR_FILE" ]; then
        error "JAR not found: $JAR_FILE. Run 'cmd app build' first."
    fi

    info "Starting Spring Boot application..."
    cd "$WORKSPACE"
    nohup java -jar "$JAR_FILE" > "$WORKSPACE/logs/app.log" 2>&1 &
    echo $! > "$APP_PID_FILE"

    sleep 2
    if app_is_running; then
        success "Application started (PID: $(cat $APP_PID_FILE))"
        info "Log: $WORKSPACE/logs/app.log"
        info "Internal: http://localhost:${DEV_PORT}/"
        info "External: http://localhost:${DEV_PORT_HOST}/"
    else
        error "Failed to start application. Check logs/app.log"
    fi
}

app_stop() {
    local STOPPED=0

    # Stop main application process
    if [ -f "$APP_PID_FILE" ]; then
        local PID=$(cat "$APP_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            info "Stopping application (PID: $PID)..."
            
            # Kill child processes first (for mvn spring-boot:run)
            pkill -P "$PID" 2>/dev/null || true
            
            # Kill main process
            kill "$PID" 2>/dev/null || true

            # Wait for process to stop
            local COUNT=0
            while kill -0 "$PID" 2>/dev/null && [ $COUNT -lt 10 ]; do
                sleep 1
                COUNT=$((COUNT + 1))
            done

            if kill -0 "$PID" 2>/dev/null; then
                warn "Force killing application..."
                kill -9 "$PID" 2>/dev/null || true
                pkill -9 -P "$PID" 2>/dev/null || true
            fi
            
            STOPPED=1
        fi
        rm -f "$APP_PID_FILE"
    fi

    # Stop watcher process if exists
    if [ -f "$APP_WATCH_PID_FILE" ]; then
        local WATCH_PID=$(cat "$APP_WATCH_PID_FILE")
        if kill -0 "$WATCH_PID" 2>/dev/null; then
            info "Stopping file watcher (PID: $WATCH_PID)..."
            kill "$WATCH_PID" 2>/dev/null || true
            kill -9 "$WATCH_PID" 2>/dev/null || true
            STOPPED=1
        fi
        rm -f "$APP_WATCH_PID_FILE"
    fi

    # Clean up timestamp file
    rm -f "$WORKSPACE/.watch_timestamp"

    if [ $STOPPED -eq 1 ]; then
        success "Application stopped"
    else
        info "Application is not running"
    fi
}

app_restart() {
    app_stop
    sleep 1
    app_start
}

app_status() {
    load_env
    echo "=== Spring Boot Application Status ==="

    if app_is_running; then
        local PID=$(cat "$APP_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        
        # Check if it's Maven or JAR
        if ps -p "$PID" -o command= | grep -q "mvn"; then
            echo "Mode: DEVELOPMENT (mvn spring-boot:run)"
        else
            echo "Mode: PRODUCTION (JAR)"
        fi
        
        echo "Internal: http://localhost:${DEV_PORT}/"
        echo "External: http://localhost:${DEV_PORT_HOST}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
        
        # Show watcher if exists
        if [ -f "$APP_WATCH_PID_FILE" ]; then
            local WATCH_PID=$(cat "$APP_WATCH_PID_FILE")
            if kill -0 "$WATCH_PID" 2>/dev/null; then
                echo ""
                echo "File watcher: RUNNING (PID: $WATCH_PID)"
            fi
        fi
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "JAR: $WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"
    if [ -f "$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar" ]; then
        echo "JAR exists: YES"
    else
        echo "JAR exists: NO (run 'cmd app build')"
    fi
}

app_is_running() {
    if [ -f "$APP_PID_FILE" ]; then
        local PID=$(cat "$APP_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$APP_PID_FILE"
    fi
    return 1
}

app_run() {
    load_env
    
    if app_is_running; then
        warn "Application is already running (PID: $(cat $APP_PID_FILE))"
        info "Use 'cmd app stop' to stop it first"
        return 0
    fi

    info "Starting Spring Boot in development mode with auto-reload..."
    cd "$WORKSPACE"

    # Create timestamp file for tracking changes
    TIMESTAMP_FILE="$WORKSPACE/tmp/.watch_timestamp"
    touch "$TIMESTAMP_FILE"

    # Start a background process to watch for changes and compile
    (
        while true; do
            sleep 2
            # Check if any Java file is newer than our timestamp
            if find src/main/java -name '*.java' -newer "$TIMESTAMP_FILE" 2>/dev/null | grep -q .; then
                echo "[WATCH] Detected changes, recompiling..."
                touch "$TIMESTAMP_FILE"
                mvn compile -q 2>&1 | grep -v "^\[INFO\]" || true
                echo "[WATCH] Compilation done"
            fi
        done
    ) &
    WATCH_PID=$!
    echo $WATCH_PID > "$APP_WATCH_PID_FILE"

    info "File watcher started (PID: $WATCH_PID)"
    info "DevTools enabled - save a Java file and it will auto-reload"

    # Start Spring Boot in background
    nohup mvn spring-boot:run > "$WORKSPACE/logs/app.log" 2>&1 &
    MAVEN_PID=$!
    echo $MAVEN_PID > "$APP_PID_FILE"

    sleep 3
    if app_is_running; then
        success "Application started in development mode (PID: $MAVEN_PID)"
        info "Log: $WORKSPACE/logs/app.log"
        info "Internal: http://localhost:${DEV_PORT}/"
        info "External: http://localhost:${DEV_PORT_HOST}/"
        info "Use 'cmd app stop' to stop the application"
        info "Use 'tail -f logs/app.log' to follow the logs"
    else
        # Clean up watcher if app failed to start
        kill $WATCH_PID 2>/dev/null || true
        rm -f "$APP_WATCH_PID_FILE"
        rm -f "$TIMESTAMP_FILE"
        error "Failed to start application. Check logs/app.log"
    fi
}

# ============================================================================
# GUI Operations (Vite/Svelte)
# ============================================================================

GUI_PID_FILE="$WORKSPACE/tmp/gui.pid"
GUI_DIR="$WORKSPACE/gui"

gui_build() {
    load_env

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Building Svelte application..."
    cd "$GUI_DIR"
    npm run build
    success "GUI build completed (output: src/main/resources/static/)"
}

gui_run() {
    load_env

    if gui_is_running; then
        warn "Vite dev server is already running (PID: $(cat $GUI_PID_FILE))"
        return 0
    fi

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Starting Vite dev server..."
    cd "$GUI_DIR"
    nohup npm run dev > "$WORKSPACE/logs/gui.log" 2>&1 &
    echo $! > "$GUI_PID_FILE"

    sleep 2
    if gui_is_running; then
        success "Vite dev server started (PID: $(cat $GUI_PID_FILE))"
        info "Log: $WORKSPACE/logs/gui.log"
        info "URL: http://localhost:${VITE_PORT}/"
        info "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
    else
        error "Failed to start Vite. Check logs/gui.log"
    fi
}

gui_stop() {
    if ! gui_is_running; then
        info "Vite dev server is not running"
        return 0
    fi

    local PID=$(cat "$GUI_PID_FILE")
    info "Stopping Vite dev server (PID: $PID)..."

    # Kill the process and its children (node processes)
    pkill -P "$PID" 2>/dev/null || true
    kill "$PID" 2>/dev/null || true

    sleep 1
    if kill -0 "$PID" 2>/dev/null; then
        kill -9 "$PID" 2>/dev/null || true
    fi

    rm -f "$GUI_PID_FILE"
    success "Vite dev server stopped"
}

gui_restart() {
    gui_stop
    sleep 1
    gui_run
}

gui_status() {
    load_env
    echo "=== Vite/Svelte GUI Status ==="

    if gui_is_running; then
        local PID=$(cat "$GUI_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        echo "URL: http://localhost:${VITE_PORT}/"
        echo "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "GUI directory: $GUI_DIR"
    if [ -d "$GUI_DIR" ]; then
        echo "Directory exists: YES"
    else
        echo "Directory exists: NO"
    fi
}

gui_is_running() {
    if [ -f "$GUI_PID_FILE" ]; then
        local PID=$(cat "$GUI_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$GUI_PID_FILE"
    fi
    return 1
}

# ============================================================================

# ============================================================================
# Git Operations
# ============================================================================

# Simplified git functions - uses git remote URL to get repo name

# Updates a git repository (stage, commit, push)
update_git_repo() {
    local REPO_DIR="$1"

    info "Updating repository in $REPO_DIR..."

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Stage changes
    info "  Staging changes..."
    git add . || { warn "Failed to stage changes"; cd "$WORKSPACE"; return 1; }

    # Commit changes
    info "  Creating commit..."
    if git commit -m "updated" 2>/dev/null; then
        info "  Changes committed"
    else
        info "  No changes to commit"
        cd "$WORKSPACE"
        return 0
    fi

    # Push to remote
    info "  Pushing to remote..."
    if git push 2>/dev/null; then
        success "Successfully pushed"
    else
        warn "Failed to push changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Pulls changes from git repository
pull_git_repo() {
    local REPO_DIR="$1"

    info "Pulling repository in $REPO_DIR..."

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Pull from remote
    info "  Pulling from remote..."
    if git pull 2>/dev/null; then
        success "Successfully pulled"
    else
        warn "Failed to pull changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Push changes to git repository
git_push() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Push changes to remote ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git push for $REPO_NAME..."
    update_git_repo "$GIT_REPO_DIR"
    info "Git push completed"
}

# Pull changes from git repository
git_pull() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Pull changes from remote ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git pull for $REPO_NAME..."
    pull_git_repo "$GIT_REPO_DIR"
    info "Git pull completed"
}

# Sync git repository (pull + push)
git_sync() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Sync repository ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git sync for $REPO_NAME..."
    pull_git_repo "$GIT_REPO_DIR"
    update_git_repo "$GIT_REPO_DIR"
    info "Git sync completed"
}

# Helper: Auto-stash uncommitted changes with branch name
auto_stash_save() {
    local CURRENT_BRANCH="$1"
    local STASH_NAME="autostash-${CURRENT_BRANCH}"

    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        info "  Saving uncommitted changes to stash..."
        git stash push -u -m "$STASH_NAME" >/dev/null 2>&1 || {
            warn "Failed to stash changes"
            return 1
        }
        success "  Uncommitted changes stashed as '$STASH_NAME'"
        return 0
    fi
    return 1
}

# Helper: Auto-pop stash for a specific branch
auto_stash_pop() {
    local TARGET_BRANCH="$1"
    local STASH_NAME="autostash-${TARGET_BRANCH}"

    # Check if stash with this name exists
    if git stash list | grep -q "$STASH_NAME"; then
        local STASH_INDEX=$(git stash list | grep -n "$STASH_NAME" | head -1 | cut -d: -f1)
        STASH_INDEX=$((STASH_INDEX - 1))

        info "  Restoring stash '$STASH_NAME'..."
        if git stash pop "stash@{$STASH_INDEX}" >/dev/null 2>&1; then
            success "  Uncommitted changes restored"
            return 0
        else
            warn "Failed to restore stash. You may need to resolve conflicts."
            warn "Run 'git stash list' to see available stashes"
            return 1
        fi
    fi
    return 1
}

# Fetch and initialize repo from remote
git_fetch() {
    load_env

    # Must be run from project root
    if [ "$(pwd)" != "$WORKSPACE" ]; then
        cd "$WORKSPACE"
    fi

    # Must not have .git folder
    if [ -d "$WORKSPACE/.git" ]; then
        error "Git repository already exists. Remove .git folder first if you want to reinitialize."
    fi

    [ -z "$PROJECT_NAME" ] && error "PROJECT_NAME not set in .env file"
    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    local GIT_URL="https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${PROJECT_NAME}.git"

    info "Initializing repository from remote..."
    info "  Project: $PROJECT_NAME"
    info "  User: $GIT_USER"

    cd "$WORKSPACE"

    info "  Running git init..."
    git init || error "Failed to initialize git repository"

    info "  Adding remote origin..."
    git remote add origin "$GIT_URL" || error "Failed to add remote origin"

    info "  Fetching from origin..."
    git fetch origin || error "Failed to fetch from origin"

    info "  Resetting to origin/main..."
    git reset --hard origin/main || error "Failed to reset to origin/main"

    info "  Renaming branch to main..."
    git branch -m master main 2>/dev/null || true

    info "  Setting upstream..."
    git branch -u origin/main || error "Failed to set upstream"

    success "Repository initialized from remote"
}

# Show current branch or create/switch to a branch
git_branch() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    local BASE_BRANCH="${3:-main}"  # Default to main if not specified
    load_env

    # If no branch name provided, show current branch
    if [ -z "$BRANCH_NAME" ]; then
        # Determine repo directory
        if [ -z "$REPO_PATH" ]; then
            GIT_REPO_DIR="$WORKSPACE"
        elif [[ "$REPO_PATH" = /* ]]; then
            GIT_REPO_DIR="$REPO_PATH"
        else
            GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
        fi

        if [ ! -d "$GIT_REPO_DIR/.git" ]; then
            error "$GIT_REPO_DIR is not a git repository"
        fi

        git -C "$GIT_REPO_DIR" branch --show-current
        return 0
    fi

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")

    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    info "Processing branch '$BRANCH_NAME' from '$BASE_BRANCH' in $REPO_NAME..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Get current branch and auto-stash if needed
    CURRENT_BRANCH=$(git branch --show-current)
    STASHED=false
    if auto_stash_save "$CURRENT_BRANCH"; then
        STASHED=true
    fi

    # Check if target branch already exists locally
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        info "  Branch '$BRANCH_NAME' exists locally, switching..."
        git switch "$BRANCH_NAME" || error "Failed to switch to branch"

        # Restore stash for this branch if exists
        auto_stash_pop "$BRANCH_NAME"

        # Check if branch exists on remote and push if not
        if ! git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            info "  Branch '$BRANCH_NAME' does not exist on remote, pushing..."
            if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
                success "Branch '$BRANCH_NAME' pushed to remote"
            else
                warn "Failed to push branch to remote"
                cd "$WORKSPACE"
                return 1
            fi
        else
            info "  Branch '$BRANCH_NAME' already exists on remote"
        fi

        cd "$WORKSPACE"
        success "Switched to existing branch '$BRANCH_NAME' in $REPO_NAME"
        return 0
    fi

    # Verify base branch exists locally or on remote
    if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
        # Check if exists on remote
        if git ls-remote --exit-code --heads origin "$BASE_BRANCH" >/dev/null 2>&1; then
            info "  Base branch '$BASE_BRANCH' found on remote, fetching..."
            git fetch origin "$BASE_BRANCH:$BASE_BRANCH" 2>/dev/null || error "Failed to fetch base branch from remote"
        else
            error "Base branch '$BASE_BRANCH' does not exist locally or on remote"
        fi
    fi

    # Switch to base branch
    info "  Switching to base branch '$BASE_BRANCH'..."
    git switch "$BASE_BRANCH" || error "Failed to switch to base branch '$BASE_BRANCH'"

    # Pull latest changes from base branch
    info "  Pulling latest changes from '$BASE_BRANCH'..."
    if git pull origin "$BASE_BRANCH" 2>/dev/null; then
        info "  Base branch '$BASE_BRANCH' updated"
    else
        warn "Failed to pull from remote. Creating branch from local state."
    fi

    # Create new branch from base
    info "  Creating new branch '$BRANCH_NAME' from '$BASE_BRANCH'..."
    git switch -c "$BRANCH_NAME" || error "Failed to create branch '$BRANCH_NAME'"

    # Restore stashed changes from original branch onto the new branch
    if [ "$STASHED" = true ]; then
        auto_stash_pop "$CURRENT_BRANCH"
    fi

    # Push new branch to remote
    info "  Pushing new branch '$BRANCH_NAME' to remote..."
    if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
        success "Branch '$BRANCH_NAME' created and pushed to remote"
    else
        warn "Branch created locally but failed to push to remote"
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
    success "Git branch operation completed for '$BRANCH_NAME' (from '$BASE_BRANCH') in $REPO_NAME"
}

# Merge branch into main and delete
git_merge() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    load_env

    [ -z "$BRANCH_NAME" ] && error "Branch name is required. Use: cmd git merge -b <branch-name>"

    if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
        error "Cannot merge main/master branch into itself"
    fi

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Merge branch '$BRANCH_NAME' into main and delete it ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Processing merge of '$BRANCH_NAME' in $REPO_NAME..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Detect main branch name
    local MAIN_BRANCH="main"
    if git show-ref --verify --quiet "refs/heads/master"; then
        if ! git show-ref --verify --quiet "refs/heads/main"; then
            MAIN_BRANCH="master"
        fi
    fi

    # Check if branch exists locally
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        error "Branch '$BRANCH_NAME' does not exist locally"
    fi

    # Switch to main branch
    info "  Switching to '$MAIN_BRANCH' branch..."
    git switch "$MAIN_BRANCH" || error "Failed to switch to $MAIN_BRANCH"

    # Merge the branch
    info "  Merging '$BRANCH_NAME' into '$MAIN_BRANCH'..."
    if git merge "$BRANCH_NAME" --no-edit 2>/dev/null; then
        success "Branch '$BRANCH_NAME' merged successfully"
    else
        error "Merge failed. Resolve conflicts manually."
    fi

    # Delete branch locally
    info "  Deleting local branch '$BRANCH_NAME'..."
    if git branch -d "$BRANCH_NAME" 2>/dev/null; then
        info "  Local branch '$BRANCH_NAME' deleted"
    else
        warn "Failed to delete local branch (use -D to force)"
    fi

    # Delete branch from remote
    if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
        info "  Deleting remote branch '$BRANCH_NAME'..."
        if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
            success "Remote branch '$BRANCH_NAME' deleted"
        else
            warn "Failed to delete remote branch"
        fi
    fi

    cd "$WORKSPACE"

    info "Git merge completed for $REPO_NAME"
    info "Note: Use 'cmd git push' to push merged changes to remote"
}

# ============================================================================
# Sync Operations (rsync based on .sync config)
# ============================================================================

# Synchronize directories based on .sync configuration file
sync_repo() {
    local SYNC_DIR="$1"

    if [ -z "$SYNC_DIR" ]; then
        error "Devi specificare la cartella contenente .sync"
    fi

    # Convert to absolute path if relative
    if [[ "$SYNC_DIR" != /* ]]; then
        SYNC_DIR="$WORKSPACE/$SYNC_DIR"
    fi

    local CONFIG_FILE="$SYNC_DIR/.sync"

    if [ ! -f "$CONFIG_FILE" ]; then
        error "File di configurazione .sync non trovato in $SYNC_DIR"
    fi

    info "Starting sync from $CONFIG_FILE..."

    while IFS= read -r line || [ -n "$line" ]; do
        # Ignora righe vuote o commenti
        [ -z "$line" ] && continue
        case "$line" in \#*) continue ;; esac

        ORIG=$(echo "$line" | cut -d;\ -f1)
        DEST=$(echo "$line" | cut -d;\ -f2)
        INCLUDE_ENTRIES=$(echo "$line" | cut -d;\ -f3)
        EXCLUDE_ENTRIES=$(echo "$line" | cut -d;\ -f4)

        info "  Syncing: $ORIG -> $DEST"

        # Prepara le opzioni include
        INCLUDE_OPTS=""
        IFS=','
        for i in $INCLUDE_ENTRIES; do
            [ -n "$i" ] && INCLUDE_OPTS="$INCLUDE_OPTS --include='$i'"
        done
        unset IFS

        # Prepara le opzioni exclude
        EXCLUDE_OPTS=""
        IFS=','
        for e in $EXCLUDE_ENTRIES; do
            [ -n "$e" ] && EXCLUDE_OPTS="$EXCLUDE_OPTS --exclude='$e'"
        done
        unset IFS

        # Esegui rsync
        if eval rsync -av --delete $INCLUDE_OPTS $EXCLUDE_OPTS "$ORIG/" "$DEST/" >/dev/null 2>&1; then
            success "  Synced: $ORIG -> $DEST"
        else
            warn "  Failed to sync: $ORIG -> $DEST"
        fi
    done < "$CONFIG_FILE"

    success "Sync completed"
}

# Main sync command handler
sync_main() {
    local REPO_PATH="$1"

    if [ -z "$REPO_PATH" ]; then
        error "Repository path is required. Use: cmd sync -r <repo>"
    fi

    sync_repo "$REPO_PATH"
}

# ============================================================================
# Command parsing
# ============================================================================

case "$1" in
    app)
        case "$2" in
            build)
                app_build
                ;;
            run)
                app_run
                ;;
            start)
                app_start
                ;;
            stop)
                app_stop
                ;;
            restart)
                app_restart
                ;;
            status)
                app_status
                ;;
            *)
                error "Unknown app command: $2. Use: build, run, start, stop, restart, status"
                ;;
        esac
        ;;
    gui)
        case "$2" in
            build)
                gui_build
                ;;
            run)
                gui_run
                ;;
            stop)
                gui_stop
                ;;
            restart)
                gui_restart
                ;;
            status)
                gui_status
                ;;
            *)
                error "Unknown gui command: $2. Use: build, run, stop, restart, status"
                ;;
        esac
        ;;
    git)
        GIT_CMD="$2"
        REPO_PATH=""
        BASE_BRANCH=""
        BRANCH_NAME=""
        shift 2

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                -b|--branch)
                    BRANCH_NAME="$2"
                    shift 2
                    ;;
                -f|--from)
                    BASE_BRANCH="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        case "$GIT_CMD" in
            push)
                git_push "$REPO_PATH"
                ;;
            pull)
                git_pull "$REPO_PATH"
                ;;
            sync)
                git_sync "$REPO_PATH"
                ;;
            fetch)
                git_fetch
                ;;
            branch)
                git_branch "$BRANCH_NAME" "$REPO_PATH" "$BASE_BRANCH"
                ;;
            merge)
                git_merge "$BRANCH_NAME" "$REPO_PATH"
                ;;
            *)
                error "Unknown git command: $GIT_CMD. Use: push, pull, sync, fetch, branch, merge"
                ;;
        esac
        ;;
    sync)
        REPO_PATH=""
        BASE_BRANCH=""
        shift 1

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        sync_main "$REPO_PATH"
        ;;
    -h|--help|help|"")
        show_help
        ;;
    *)
        error "Unknown command: $1. Use 'cmd --help' for usage."
        ;;
esac
