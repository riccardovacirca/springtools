#!/bin/bash
set -e

# Project utility script
WORKSPACE="/usr/src/app"

# Helper functions
error() { printf 'ERROR: %s\n' "$1" >&2; exit 1; }
info() { printf 'INFO: %s\n' "$1"; }
warn() { printf 'WARNING: %s\n' "$1" >&2; }
success() { printf 'âœ“ SUCCESS: %s\n' "$1"; }

# Ask for user confirmation
confirm() {
    printf '%s [y/N]: ' "$1"
    read -r answer
    case "$answer" in
        [Yy]|[Yy][Ee][Ss]) return 0 ;;
        *) return 1 ;;
    esac
}

# Load environment variables from .env
load_env() {
    if [ -f "$WORKSPACE/.env" ]; then
        set -a
        . "$WORKSPACE/.env"
        set +a
    fi
}

# Show help
show_help() {
    cat << 'HELPEOF'
Usage: cmd COMMAND [OPTIONS]

App (Spring Boot):
  app build                Build application
  app run                  Run in dev mode (foreground)
  app start                Start production JAR (background)
  app stop                 Stop application
  app restart              Restart application
  app status               Show status
  app format               Format code with Spotless

GUI (Vite/Svelte):
  gui build                Build GUI for production
  gui run                  Run Vite dev server (foreground)
  gui stop                 Stop Vite server
  gui restart              Restart Vite server
  gui status               Show status

Git:
  git push [-r <path>]     Stage, commit and push
  git pull [-r <path>]     Pull from remote
  git sync [-r <path>]     Pull + commit + push
  git fetch                Initialize repo from remote (only in project root, no .git)
  git branch [-r <path>]   Show current branch name
  git branch -b <name> [-r <path>] [-f <base-branch>]   Create branch from base (default: main)
  git merge -b <name> [-r <path>]    Merge branch to main and delete
  git update               Update git config and remote URL from .env (GIT_USER, GIT_TOKEN)

Database:
  db                       Open interactive database CLI
  db -f <file>             Execute SQL or CSV file
  db reset                 Reset database (drop and re-run migrations)

Sync:
  sync -r <path>           Sync using .sync config file

Ngrok:
  ngrok auth               Configure ngrok authtoken (if NGROK_TOKEN is set in .env)
  ngrok run                Expose Spring app to public URL

Options:
  -h, --help               Show this help
  -r, --repo <path>        Git repo path (default: project root)
  -b, --branch <name>      Branch name
  -f, --from <branch>       Base branch (default: main)
HELPEOF
}

# ============================================================================
# App Operations (Spring Boot)
# ============================================================================

APP_PID_FILE="$WORKSPACE/tmp/app.pid"
APP_WATCH_PID_FILE="$WORKSPACE/tmp/app.watch.pid"

app_build() {
    load_env
    info "Building Spring Boot application..."
    cd "$WORKSPACE"
    mvn clean package -DskipTests
    success "Build completed"
}

app_start() {
    load_env

    if app_is_running; then
        warn "Application is already running (PID: $(cat $APP_PID_FILE))"
        return 0
    fi

    local JAR_FILE="$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"

    if [ ! -f "$JAR_FILE" ]; then
        error "JAR not found: $JAR_FILE. Run 'cmd app build' first."
    fi

    info "Starting Spring Boot application..."
    cd "$WORKSPACE"
    nohup java -jar "$JAR_FILE" > "$WORKSPACE/logs/app.log" 2>&1 &
    echo $! > "$APP_PID_FILE"

    sleep 2
    if app_is_running; then
        success "Application started (PID: $(cat $APP_PID_FILE))"
        info "Log: $WORKSPACE/logs/app.log"
        info "Internal: http://localhost:${DEV_PORT}/"
        info "External: http://localhost:${DEV_PORT_HOST}/"
    else
        error "Failed to start application. Check logs/app.log"
    fi
}

app_stop() {
    local STOPPED=0

    # Stop main application process
    if [ -f "$APP_PID_FILE" ]; then
        local PID=$(cat "$APP_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            info "Stopping application (PID: $PID)..."
            
            # Kill child processes first (for mvn spring-boot:run)
            pkill -P "$PID" 2>/dev/null || true
            
            # Kill main process
            kill "$PID" 2>/dev/null || true

            # Wait for process to stop
            local COUNT=0
            while kill -0 "$PID" 2>/dev/null && [ $COUNT -lt 10 ]; do
                sleep 1
                COUNT=$((COUNT + 1))
            done

            if kill -0 "$PID" 2>/dev/null; then
                warn "Force killing application..."
                kill -9 "$PID" 2>/dev/null || true
                pkill -9 -P "$PID" 2>/dev/null || true
            fi
            
            STOPPED=1
        fi
        rm -f "$APP_PID_FILE"
    fi

    # Stop watcher process if exists
    if [ -f "$APP_WATCH_PID_FILE" ]; then
        local WATCH_PID=$(cat "$APP_WATCH_PID_FILE")
        if kill -0 "$WATCH_PID" 2>/dev/null; then
            info "Stopping file watcher (PID: $WATCH_PID)..."
            kill "$WATCH_PID" 2>/dev/null || true
            kill -9 "$WATCH_PID" 2>/dev/null || true
            STOPPED=1
        fi
        rm -f "$APP_WATCH_PID_FILE"
    fi

    # Clean up timestamp file
    rm -f "$WORKSPACE/.watch_timestamp"

    if [ $STOPPED -eq 1 ]; then
        success "Application stopped"
    else
        info "Application is not running"
    fi
}

app_restart() {
    app_stop
    sleep 1
    app_start
}

app_status() {
    load_env
    echo "=== Spring Boot Application Status ==="

    if app_is_running; then
        local PID=$(cat "$APP_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        
        # Check if it's Maven or JAR
        if ps -p "$PID" -o command= | grep -q "mvn"; then
            echo "Mode: DEVELOPMENT (mvn spring-boot:run)"
        else
            echo "Mode: PRODUCTION (JAR)"
        fi
        
        echo "Internal: http://localhost:${DEV_PORT}/"
        echo "External: http://localhost:${DEV_PORT_HOST}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
        
        # Show watcher if exists
        if [ -f "$APP_WATCH_PID_FILE" ]; then
            local WATCH_PID=$(cat "$APP_WATCH_PID_FILE")
            if kill -0 "$WATCH_PID" 2>/dev/null; then
                echo ""
                echo "File watcher: RUNNING (PID: $WATCH_PID)"
            fi
        fi
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "JAR: $WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar"
    if [ -f "$WORKSPACE/target/${PROJECT_NAME}-${ARTIFACT_VERSION}.jar" ]; then
        echo "JAR exists: YES"
    else
        echo "JAR exists: NO (run 'cmd app build')"
    fi
}

app_is_running() {
    if [ -f "$APP_PID_FILE" ]; then
        local PID=$(cat "$APP_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$APP_PID_FILE"
    fi
    return 1
}

app_run() {
    load_env

    if app_is_running; then
        warn "Application is already running (PID: $(cat $APP_PID_FILE))"
        info "Use 'cmd app stop' to stop it first"
        return 0
    fi

    info "Starting Spring Boot in development mode (foreground)..."
    info "Internal: http://localhost:${DEV_PORT}/"
    info "External: http://localhost:${DEV_PORT_HOST}/"
    info "Press Ctrl+C to stop"
    cd "$WORKSPACE"

    # Start Spring Boot in foreground
    mvn spring-boot:run
}

# ============================================================================
# GUI Operations (Vite/Svelte)
# ============================================================================

GUI_PID_FILE="$WORKSPACE/tmp/gui.pid"
GUI_DIR="$WORKSPACE/svelte"

gui_build() {
    load_env

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Building Svelte application..."
    cd "$GUI_DIR"
    npm run build
    success "GUI build completed (output: src/main/resources/static/)"
}

gui_run() {
    load_env

    if gui_is_running; then
        warn "Vite dev server is already running (PID: $(cat $GUI_PID_FILE))"
        return 0
    fi

    if [ ! -d "$GUI_DIR" ]; then
        error "GUI directory not found: $GUI_DIR"
    fi

    info "Starting Vite dev server (foreground)..."
    info "URL: http://localhost:${VITE_PORT}/"
    info "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
    info "Press Ctrl+C to stop"
    cd "$GUI_DIR"

    # Start Vite in foreground
    npm run dev
}

gui_stop() {
    if ! gui_is_running; then
        info "Vite dev server is not running"
        return 0
    fi

    local PID=$(cat "$GUI_PID_FILE")
    info "Stopping Vite dev server (PID: $PID)..."

    # Kill the process and its children (node processes)
    pkill -P "$PID" 2>/dev/null || true
    kill "$PID" 2>/dev/null || true

    sleep 1
    if kill -0 "$PID" 2>/dev/null; then
        kill -9 "$PID" 2>/dev/null || true
    fi

    rm -f "$GUI_PID_FILE"
    success "Vite dev server stopped"
}

gui_restart() {
    gui_stop
    sleep 1
    gui_run
}

gui_status() {
    load_env
    echo "=== Vite/Svelte GUI Status ==="

    if gui_is_running; then
        local PID=$(cat "$GUI_PID_FILE")
        echo "Status: RUNNING"
        echo "PID: $PID"
        echo "URL: http://localhost:${VITE_PORT}/"
        echo "API proxy: /api/* -> http://localhost:${DEV_PORT}/"
        echo ""
        echo "Process info:"
        ps -p "$PID" -o pid,ppid,%cpu,%mem,etime,command 2>/dev/null || true
    else
        echo "Status: STOPPED"
    fi

    echo ""
    echo "GUI directory: $GUI_DIR"
    if [ -d "$GUI_DIR" ]; then
        echo "Directory exists: YES"
    else
        echo "Directory exists: NO"
    fi
}

gui_is_running() {
    if [ -f "$GUI_PID_FILE" ]; then
        local PID=$(cat "$GUI_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            return 0
        fi
        rm -f "$GUI_PID_FILE"
    fi
    return 1
}

# ============================================================================
# Ngrok Operations
# ============================================================================

ngrok_auth() {
    load_env

    if [ -z "$NGROK_TOKEN" ]; then
        warn "NGROK_TOKEN not set in .env file"
        info "Add your ngrok token to .env file:"
        info "  NGROK_TOKEN=your_token_here"
        info ""
        info "Get your token from: https://dashboard.ngrok.com/get-started/your-authtoken"
        return 1
    fi

    info "Configuring ngrok authtoken..."
    ngrok config add-authtoken "$NGROK_TOKEN"
    success "Ngrok authtoken configured"
}

ngrok_run() {
    load_env

    if ! command -v ngrok >/dev/null 2>&1; then
        error "ngrok is not installed. Install it first with the setup script."
    fi

    if [ -z "$NGROK_TOKEN" ]; then
        warn "NGROK_TOKEN not set in .env file"
        info "Run 'cmd ngrok auth' first to configure your token"
        return 1
    fi

    local PORT="${DEV_PORT:-8080}"

    info "Starting ngrok tunnel..."
    info "Exposing http://localhost:$PORT to public URL"
    info "Press Ctrl+C to stop"
    ngrok http "$PORT"
}

# ============================================================================
# Git Operations
# ============================================================================

# Simplified git functions - uses git remote URL to get repo name

# Updates a git repository (stage, commit, push)
update_git_repo() {
    local REPO_DIR="$1"

    info "Updating repository in $REPO_DIR..."

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Stage changes
    info "  Staging changes..."
    git add . || { warn "Failed to stage changes"; cd "$WORKSPACE"; return 1; }

    # Commit changes
    info "  Creating commit..."
    if git commit -m "updated" 2>/dev/null; then
        info "  Changes committed"
    else
        info "  No changes to commit"
        cd "$WORKSPACE"
        return 0
    fi

    # Push to remote
    info "  Pushing to remote..."
    if git push 2>/dev/null; then
        success "Successfully pushed"
    else
        warn "Failed to push changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Pulls changes from git repository
pull_git_repo() {
    local REPO_DIR="$1"

    info "Pulling repository in $REPO_DIR..."

    cd "$REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Pull from remote
    info "  Pulling from remote..."
    if git pull 2>/dev/null; then
        success "Successfully pulled"
    else
        warn "Failed to pull changes. Check credentials and network."
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
}

# Push changes to git repository
git_push() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Push changes to remote ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git push for $REPO_NAME..."
    update_git_repo "$GIT_REPO_DIR"
    info "Git push completed"
}

# Pull changes from git repository
git_pull() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Pull changes from remote ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git pull for $REPO_NAME..."
    pull_git_repo "$GIT_REPO_DIR"
    info "Git pull completed"
}

# Sync git repository (pull + push)
git_sync() {
    local REPO_PATH="$1"
    load_env

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Sync repository ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Starting git sync for $REPO_NAME..."
    pull_git_repo "$GIT_REPO_DIR"
    update_git_repo "$GIT_REPO_DIR"
    info "Git sync completed"
}

# Helper: Auto-stash uncommitted changes with branch name
auto_stash_save() {
    local CURRENT_BRANCH="$1"
    local STASH_NAME="autostash-${CURRENT_BRANCH}"

    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        info "  Saving uncommitted changes to stash..."
        git stash push -u -m "$STASH_NAME" >/dev/null 2>&1 || {
            warn "Failed to stash changes"
            return 1
        }
        success "  Uncommitted changes stashed as '$STASH_NAME'"
        return 0
    fi
    return 1
}

# Helper: Auto-pop stash for a specific branch
auto_stash_pop() {
    local TARGET_BRANCH="$1"
    local STASH_NAME="autostash-${TARGET_BRANCH}"

    # Check if stash with this name exists
    if git stash list | grep -q "$STASH_NAME"; then
        local STASH_INDEX=$(git stash list | grep -n "$STASH_NAME" | head -1 | cut -d: -f1)
        STASH_INDEX=$((STASH_INDEX - 1))

        info "  Restoring stash '$STASH_NAME'..."
        if git stash pop "stash@{$STASH_INDEX}" >/dev/null 2>&1; then
            success "  Uncommitted changes restored"
            return 0
        else
            warn "Failed to restore stash. You may need to resolve conflicts."
            warn "Run 'git stash list' to see available stashes"
            return 1
        fi
    fi
    return 1
}

# Fetch and initialize repo from remote
git_fetch() {
    load_env

    # Must be run from project root
    if [ "$(pwd)" != "$WORKSPACE" ]; then
        cd "$WORKSPACE"
    fi

    # Must not have .git folder
    if [ -d "$WORKSPACE/.git" ]; then
        error "Git repository already exists. Remove .git folder first if you want to reinitialize."
    fi

    [ -z "$PROJECT_NAME" ] && error "PROJECT_NAME not set in .env file"
    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    local GIT_URL="https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${PROJECT_NAME}.git"

    info "Initializing repository from remote..."
    info "  Project: $PROJECT_NAME"
    info "  User: $GIT_USER"

    cd "$WORKSPACE"

    info "  Running git init..."
    git init || error "Failed to initialize git repository"

    info "  Adding remote origin..."
    git remote add origin "$GIT_URL" || error "Failed to add remote origin"

    info "  Fetching from origin..."
    git fetch origin || error "Failed to fetch from origin"

    info "  Resetting to origin/main..."
    git reset --hard origin/main || error "Failed to reset to origin/main"

    info "  Renaming branch to main..."
    git branch -m master main 2>/dev/null || true

    info "  Setting upstream..."
    git branch -u origin/main || error "Failed to set upstream"

    success "Repository initialized from remote"
}

# Show current branch or create/switch to a branch
git_branch() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    local BASE_BRANCH="${3:-main}"  # Default to main if not specified
    load_env

    # If no branch name provided, show current branch
    if [ -z "$BRANCH_NAME" ]; then
        # Determine repo directory
        if [ -z "$REPO_PATH" ]; then
            GIT_REPO_DIR="$WORKSPACE"
        elif [[ "$REPO_PATH" = /* ]]; then
            GIT_REPO_DIR="$REPO_PATH"
        else
            GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
        fi

        if [ ! -d "$GIT_REPO_DIR/.git" ]; then
            error "$GIT_REPO_DIR is not a git repository"
        fi

        git -C "$GIT_REPO_DIR" branch --show-current
        return 0
    fi

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")

    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    info "Processing branch '$BRANCH_NAME' from '$BASE_BRANCH' in $REPO_NAME..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Get current branch and auto-stash if needed
    CURRENT_BRANCH=$(git branch --show-current)
    STASHED=false
    if auto_stash_save "$CURRENT_BRANCH"; then
        STASHED=true
    fi

    # Check if target branch already exists locally
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        info "  Branch '$BRANCH_NAME' exists locally, switching..."
        git switch "$BRANCH_NAME" || error "Failed to switch to branch"

        # Restore stash for this branch if exists
        auto_stash_pop "$BRANCH_NAME"

        # Check if branch exists on remote and push if not
        if ! git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            info "  Branch '$BRANCH_NAME' does not exist on remote, pushing..."
            if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
                success "Branch '$BRANCH_NAME' pushed to remote"
            else
                warn "Failed to push branch to remote"
                cd "$WORKSPACE"
                return 1
            fi
        else
            info "  Branch '$BRANCH_NAME' already exists on remote"
        fi

        cd "$WORKSPACE"
        success "Switched to existing branch '$BRANCH_NAME' in $REPO_NAME"
        return 0
    fi

    # Verify base branch exists locally or on remote
    if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
        # Check if exists on remote
        if git ls-remote --exit-code --heads origin "$BASE_BRANCH" >/dev/null 2>&1; then
            info "  Base branch '$BASE_BRANCH' found on remote, fetching..."
            git fetch origin "$BASE_BRANCH:$BASE_BRANCH" 2>/dev/null || error "Failed to fetch base branch from remote"
        else
            error "Base branch '$BASE_BRANCH' does not exist locally or on remote"
        fi
    fi

    # Switch to base branch
    info "  Switching to base branch '$BASE_BRANCH'..."
    git switch "$BASE_BRANCH" || error "Failed to switch to base branch '$BASE_BRANCH'"

    # Pull latest changes from base branch
    info "  Pulling latest changes from '$BASE_BRANCH'..."
    if git pull origin "$BASE_BRANCH" 2>/dev/null; then
        info "  Base branch '$BASE_BRANCH' updated"
    else
        warn "Failed to pull from remote. Creating branch from local state."
    fi

    # Create new branch from base
    info "  Creating new branch '$BRANCH_NAME' from '$BASE_BRANCH'..."
    git switch -c "$BRANCH_NAME" || error "Failed to create branch '$BRANCH_NAME'"

    # Restore stashed changes from original branch onto the new branch
    if [ "$STASHED" = true ]; then
        auto_stash_pop "$CURRENT_BRANCH"
    fi

    # Push new branch to remote
    info "  Pushing new branch '$BRANCH_NAME' to remote..."
    if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
        success "Branch '$BRANCH_NAME' created and pushed to remote"
    else
        warn "Branch created locally but failed to push to remote"
        cd "$WORKSPACE"
        return 1
    fi

    cd "$WORKSPACE"
    success "Git branch operation completed for '$BRANCH_NAME' (from '$BASE_BRANCH') in $REPO_NAME"
}

# Merge branch into main and delete
git_merge() {
    local BRANCH_NAME="$1"
    local REPO_PATH="$2"
    load_env

    [ -z "$BRANCH_NAME" ] && error "Branch name is required. Use: cmd git merge -b <branch-name>"

    if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
        error "Cannot merge main/master branch into itself"
    fi

    # Determine repo directory
    if [ -z "$REPO_PATH" ]; then
        GIT_REPO_DIR="$WORKSPACE"
    elif [[ "$REPO_PATH" = /* ]]; then
        GIT_REPO_DIR="$REPO_PATH"
    else
        GIT_REPO_DIR="$WORKSPACE/$REPO_PATH"
    fi

    # Check if git repo exists
    if [ ! -d "$GIT_REPO_DIR/.git" ]; then
        error "$GIT_REPO_DIR is not a git repository"
    fi

    # Configure git safe directory
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true

    # Get repo name from git remote URL
    REPO_NAME=$(basename -s .git "$(git -C "$GIT_REPO_DIR" config --get remote.origin.url 2>/dev/null)")
    
    if [ -z "$REPO_NAME" ]; then
        error "Cannot determine repository name. No remote.origin.url found in $GIT_REPO_DIR"
    fi

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_EMAIL" ] && error "GIT_EMAIL not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    confirm "Merge branch '$BRANCH_NAME' into main and delete it ($REPO_NAME at $GIT_REPO_DIR)?" || exit 0

    info "Processing merge of '$BRANCH_NAME' in $REPO_NAME..."

    cd "$GIT_REPO_DIR"

    # Configure git
    git config --global --add safe.directory "$GIT_REPO_DIR" 2>/dev/null || true
    git config user.name "$GIT_USER"
    git config user.email "$GIT_EMAIL"

    # Detect main branch name
    local MAIN_BRANCH="main"
    if git show-ref --verify --quiet "refs/heads/master"; then
        if ! git show-ref --verify --quiet "refs/heads/main"; then
            MAIN_BRANCH="master"
        fi
    fi

    # Check if branch exists locally
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        error "Branch '$BRANCH_NAME' does not exist locally"
    fi

    # Switch to main branch
    info "  Switching to '$MAIN_BRANCH' branch..."
    git switch "$MAIN_BRANCH" || error "Failed to switch to $MAIN_BRANCH"

    # Merge the branch
    info "  Merging '$BRANCH_NAME' into '$MAIN_BRANCH'..."
    if git merge "$BRANCH_NAME" --no-edit 2>/dev/null; then
        success "Branch '$BRANCH_NAME' merged successfully"
    else
        error "Merge failed. Resolve conflicts manually."
    fi

    # Delete branch locally
    info "  Deleting local branch '$BRANCH_NAME'..."
    if git branch -d "$BRANCH_NAME" 2>/dev/null; then
        info "  Local branch '$BRANCH_NAME' deleted"
    else
        warn "Failed to delete local branch (use -D to force)"
    fi

    # Delete branch from remote
    if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
        info "  Deleting remote branch '$BRANCH_NAME'..."
        if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
            success "Remote branch '$BRANCH_NAME' deleted"
        else
            warn "Failed to delete remote branch"
        fi
    fi

    cd "$WORKSPACE"

    info "Git merge completed for $REPO_NAME"
    info "Note: Use 'cmd git push' to push merged changes to remote"
}

# Update git configuration with credentials from .env
git_update() {
    load_env

    [ -z "$GIT_USER" ] && error "GIT_USER not set in .env file"
    [ -z "$GIT_TOKEN" ] && error "GIT_TOKEN not set in .env file"

    info "Updating git configuration..."

    cd "$WORKSPACE"

    # Configure git safe directory
    git config --global --add safe.directory "$WORKSPACE" 2>/dev/null || true

    # Set git user name globally
    info "  Setting user.name: $GIT_USER"
    git config --global user.name "$GIT_USER"

    # Set git user email globally (if present in .env)
    if [ -n "$GIT_EMAIL" ]; then
        info "  Setting user.email: $GIT_EMAIL"
        git config --global user.email "$GIT_EMAIL"
    fi

    # Update remote URL with credentials (only if .git exists)
    if [ -d "$WORKSPACE/.git" ]; then
        # Get current remote URL to extract repo name
        CURRENT_REMOTE=$(git config --get remote.origin.url 2>/dev/null || echo "")

        if [ -n "$CURRENT_REMOTE" ]; then
            # Extract repo name from current remote URL
            REPO_NAME=$(basename -s .git "$CURRENT_REMOTE")

            # Build new remote URL with credentials
            NEW_REMOTE_URL="https://${GIT_USER}:${GIT_TOKEN}@github.com/${GIT_USER}/${REPO_NAME}.git"

            info "  Updating remote URL for repository: $REPO_NAME"
            git remote set-url origin "$NEW_REMOTE_URL"
            success "Remote URL updated"
        else
            warn "No remote origin found, skipping remote URL update"
        fi
    else
        warn "Not a git repository, skipping remote URL update"
    fi

    success "Git configuration updated successfully"
    info "User: $GIT_USER"
}

# ============================================================================
# Database Operations
# ============================================================================

# Database CLI - connect or execute files
db_cli() {
    load_env

    local FILE="$1"
    local SQLITE_DB="$WORKSPACE/${DB_DIR:-data}/${PROJECT_NAME}.db"

    # If file is provided
    if [ -n "$FILE" ]; then
        [ ! -f "$FILE" ] && error "File not found: $FILE"

        local FILE_EXT="${FILE##*.}"

        # Handle CSV files
        if [ "$FILE_EXT" = "csv" ]; then
            local TABLE_NAME=$(basename "$FILE" .csv)

            if [ "$PGSQL_ENABLED" = "y" ]; then
                info "Loading CSV into PostgreSQL table: $TABLE_NAME"
                export PGPASSWORD="$PGSQL_ROOT_PASSWORD"
                psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d "$PGSQL_NAME" \
                    -c "\\COPY $TABLE_NAME FROM '$FILE' WITH (FORMAT CSV, HEADER true, DELIMITER ';')"

            elif [ "$MARIADB_ENABLED" = "y" ]; then
                info "Loading CSV into MariaDB table: $TABLE_NAME"
                mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_USER" -p"$MARIADB_PASSWORD" "$MARIADB_NAME" \
                    -e "LOAD DATA LOCAL INFILE '$FILE' INTO TABLE $TABLE_NAME FIELDS TERMINATED BY ';' ENCLOSED BY '\"' LINES TERMINATED BY '\\n' IGNORE 1 LINES;"

            else
                # Default: SQLite
                info "Loading CSV into SQLite table: $TABLE_NAME"
                sqlite3 "$SQLITE_DB" <<EOF
.mode csv
.separator ";"
.import --skip 1 $FILE $TABLE_NAME
EOF
            fi
            success "CSV file loaded"

        # Handle SQL files
        elif [ "$FILE_EXT" = "sql" ]; then
            info "Executing SQL file: $FILE"

            if [ "$PGSQL_ENABLED" = "y" ]; then
                export PGPASSWORD="$PGSQL_ROOT_PASSWORD"
                psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d "$PGSQL_NAME" -f "$FILE"

            elif [ "$MARIADB_ENABLED" = "y" ]; then
                mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_USER" -p"$MARIADB_PASSWORD" "$MARIADB_NAME" < "$FILE"

            else
                # Default: SQLite
                sqlite3 "$SQLITE_DB" < "$FILE"
            fi
            success "SQL file executed"

        else
            error "Unsupported file type. Use .sql or .csv"
        fi

    # No file - open interactive CLI
    else
        if [ "$PGSQL_ENABLED" = "y" ]; then
            info "Connecting to PostgreSQL..."
            export PGPASSWORD="$PGSQL_ROOT_PASSWORD"
            psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d "$PGSQL_NAME"

        elif [ "$MARIADB_ENABLED" = "y" ]; then
            info "Connecting to MariaDB..."
            mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_USER" -p"$MARIADB_PASSWORD" "$MARIADB_NAME"

        else
            # Default: SQLite
            info "Connecting to SQLite: $SQLITE_DB"
            sqlite3 "$SQLITE_DB"
        fi
    fi
}

# Database reset - drop and recreate database with migrations
db_reset() {
    load_env

    local SQLITE_DB="$WORKSPACE/${DB_DIR:-data}/${PROJECT_NAME}.db"

    warn "This will DELETE all data in the database and re-run migrations!"
    confirm "Are you sure you want to reset the database?" || exit 0

    # Check if app is running and stop it
    local APP_WAS_RUNNING=false
    if app_is_running; then
        info "Stopping application..."
        app_stop
        APP_WAS_RUNNING=true
    fi

    # Delete database based on type
    if [ "$PGSQL_ENABLED" = "y" ]; then
        info "Resetting PostgreSQL database..."
        export PGPASSWORD="$PGSQL_ROOT_PASSWORD"

        # Drop and recreate database
        info "  Dropping database $PGSQL_NAME..."
        psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d postgres \
            -c "DROP DATABASE IF EXISTS $PGSQL_NAME;" 2>/dev/null || true

        info "  Creating database $PGSQL_NAME..."
        psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d postgres \
            -c "CREATE DATABASE $PGSQL_NAME;" || error "Failed to create database"

        info "  Granting privileges to $PGSQL_USER..."
        psql -h "${PROJECT_NAME}-postgres" -p 5432 -U "$PGSQL_ROOT_USER" -d "$PGSQL_NAME" \
            -c "GRANT ALL ON SCHEMA public TO \"$PGSQL_USER\";" 2>/dev/null || true

    elif [ "$MARIADB_ENABLED" = "y" ]; then
        info "Resetting MariaDB database..."

        # Drop and recreate database
        info "  Dropping database $MARIADB_NAME..."
        mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_ROOT_USER" -p"$MARIADB_ROOT_PASSWORD" \
            -e "DROP DATABASE IF EXISTS $MARIADB_NAME;" 2>/dev/null || true

        info "  Creating database $MARIADB_NAME..."
        mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_ROOT_USER" -p"$MARIADB_ROOT_PASSWORD" \
            -e "CREATE DATABASE $MARIADB_NAME;" || error "Failed to create database"

        info "  Granting privileges to $MARIADB_USER..."
        mysql -h "${PROJECT_NAME}-mariadb" -P 3306 -u "$MARIADB_ROOT_USER" -p"$MARIADB_ROOT_PASSWORD" \
            -e "GRANT ALL PRIVILEGES ON \`$MARIADB_NAME\`.* TO '$MARIADB_USER'@'%';" 2>/dev/null || true

    else
        # Default: SQLite
        info "Resetting SQLite database..."
        if [ -f "$SQLITE_DB" ]; then
            info "  Removing database file: $SQLITE_DB"
            rm -f "$SQLITE_DB" || error "Failed to remove database file"
        else
            info "  Database file does not exist, will be created on app start"
        fi
    fi

    success "Database reset completed"

    # Restart app if it was running
    if [ "$APP_WAS_RUNNING" = true ]; then
        info "Restarting application to run migrations..."
        app_start
        info "Migrations will be executed automatically by Flyway on startup"
    else
        info "Start the application with 'cmd app run' to execute migrations"
    fi
}

# ============================================================================
# Sync Operations (rsync based on .sync config)
# ============================================================================

# Synchronize directories based on .sync configuration file
sync_repo() {
    local SYNC_DIR="$1"

    if [ -z "$SYNC_DIR" ]; then
        error "Devi specificare la cartella contenente .sync"
    fi

    # Convert to absolute path if relative
    if [[ "$SYNC_DIR" != /* ]]; then
        SYNC_DIR="$WORKSPACE/$SYNC_DIR"
    fi

    local CONFIG_FILE="$SYNC_DIR/.sync"

    if [ ! -f "$CONFIG_FILE" ]; then
        error "File di configurazione .sync non trovato in $SYNC_DIR"
    fi

    info "Starting sync from $CONFIG_FILE..."

    while IFS= read -r line || [ -n "$line" ]; do
        # Ignora righe vuote o commenti
        [ -z "$line" ] && continue
        case "$line" in \#*) continue ;; esac

        ORIG=$(echo "$line" | cut -d;\ -f1)
        DEST=$(echo "$line" | cut -d;\ -f2)
        INCLUDE_ENTRIES=$(echo "$line" | cut -d;\ -f3)
        EXCLUDE_ENTRIES=$(echo "$line" | cut -d;\ -f4)

        info "  Syncing: $ORIG -> $DEST"

        # Prepara le opzioni include
        INCLUDE_OPTS=""
        IFS=','
        for i in $INCLUDE_ENTRIES; do
            [ -n "$i" ] && INCLUDE_OPTS="$INCLUDE_OPTS --include='$i'"
        done
        unset IFS

        # Prepara le opzioni exclude
        EXCLUDE_OPTS=""
        IFS=','
        for e in $EXCLUDE_ENTRIES; do
            [ -n "$e" ] && EXCLUDE_OPTS="$EXCLUDE_OPTS --exclude='$e'"
        done
        unset IFS

        # Esegui rsync
        if eval rsync -av --delete $INCLUDE_OPTS $EXCLUDE_OPTS "$ORIG/" "$DEST/" >/dev/null 2>&1; then
            success "  Synced: $ORIG -> $DEST"
        else
            warn "  Failed to sync: $ORIG -> $DEST"
        fi
    done < "$CONFIG_FILE"

    success "Sync completed"
}

# Main sync command handler
sync_main() {
    local REPO_PATH="$1"

    if [ -z "$REPO_PATH" ]; then
        error "Repository path is required. Use: cmd sync -r <repo>"
    fi

    sync_repo "$REPO_PATH"
}

# ============================================================================
# Command parsing
# ============================================================================

case "$1" in
    app)
        case "$2" in
            build)
                app_build
                ;;
            run)
                app_run
                ;;
            start)
                app_start
                ;;
            stop)
                app_stop
                ;;
            restart)
                app_restart
                ;;
            status)
                app_status
                ;;
            *)
                error "Unknown app command: $2. Use: build, run, start, stop, restart, status"
                ;;
        esac
        ;;
    gui)
        case "$2" in
            build)
                gui_build
                ;;
            run)
                gui_run
                ;;
            stop)
                gui_stop
                ;;
            restart)
                gui_restart
                ;;
            status)
                gui_status
                ;;
            *)
                error "Unknown gui command: $2. Use: build, run, stop, restart, status"
                ;;
        esac
        ;;
    git)
        GIT_CMD="$2"
        REPO_PATH=""
        BASE_BRANCH=""
        BRANCH_NAME=""
        shift 2

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                -b|--branch)
                    BRANCH_NAME="$2"
                    shift 2
                    ;;
                -f|--from)
                    BASE_BRANCH="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        case "$GIT_CMD" in
            push)
                git_push "$REPO_PATH"
                ;;
            pull)
                git_pull "$REPO_PATH"
                ;;
            sync)
                git_sync "$REPO_PATH"
                ;;
            fetch)
                git_fetch
                ;;
            branch)
                git_branch "$BRANCH_NAME" "$REPO_PATH" "$BASE_BRANCH"
                ;;
            merge)
                git_merge "$BRANCH_NAME" "$REPO_PATH"
                ;;
            update)
                git_update
                ;;
            *)
                error "Unknown git command: $GIT_CMD. Use: push, pull, sync, fetch, branch, merge, update"
                ;;
        esac
        ;;
    sync)
        REPO_PATH=""
        BASE_BRANCH=""
        shift 1

        # Parse options
        while [ $# -gt 0 ]; do
            case "$1" in
                -r|--repo)
                    REPO_PATH="$2"
                    shift 2
                    ;;
                *)
                    error "Unknown option: $1"
                    ;;
            esac
        done

        sync_main "$REPO_PATH"
        ;;
    db)
        shift 1
        if [ $# -eq 0 ]; then
            db_cli ""
        elif [ "$1" = "-f" ]; then
            [ -z "$2" ] && error "Option -f requires a file path"
            db_cli "$2"
        elif [ "$1" = "reset" ]; then
            db_reset
        else
            error "Unknown db option: $1. Use: db, db -f <file>, db reset"
        fi
        ;;
    ngrok)
        case "$2" in
            auth)
                ngrok_auth
                ;;
            run)
                ngrok_run
                ;;
            *)
                error "Unknown ngrok command: $2. Use: auth, run"
                ;;
        esac
        ;;
    -h|--help|help|"")
        show_help
        ;;
    *)
        error "Unknown command: $1. Use 'cmd --help' for usage."
        ;;
esac
